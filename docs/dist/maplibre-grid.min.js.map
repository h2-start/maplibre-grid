{"version":3,"file":"maplibre-grid.min.js","sources":["../node_modules/@babel/runtime/helpers/esm/createClass.js","../node_modules/@turf/helpers/dist/es/index.js","../node_modules/@turf/invariant/dist/es/index.js","../node_modules/@turf/distance/dist/es/index.js","../node_modules/@turf/destination/dist/es/index.js","../src/grid.js","../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../src/calc.js"],"sourcesContent":["function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}","/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexport var earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var factors = {\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    degrees: earthRadius / 111325,\n    feet: earthRadius * 3.28084,\n    inches: earthRadius * 39.37,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    meters: earthRadius,\n    metres: earthRadius,\n    miles: earthRadius / 1609.344,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    nauticalmiles: earthRadius / 1852,\n    radians: 1,\n    yards: earthRadius / 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.37,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / earthRadius,\n    yards: 1 / 1.0936,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    hectares: 0.0001,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nexport function geometry(type, coordinates, _options) {\n    if (_options === void 0) { _options = {}; }\n    switch (type) {\n        case \"Point\":\n            return point(coordinates).geometry;\n        case \"LineString\":\n            return lineString(coordinates).geometry;\n        case \"Polygon\":\n            return polygon(coordinates).geometry;\n        case \"MultiPoint\":\n            return multiPoint(coordinates).geometry;\n        case \"MultiLineString\":\n            return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\":\n            return multiPolygon(coordinates).geometry;\n        default:\n            throw new Error(type + \" is invalid\");\n    }\n}\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (!coordinates) {\n        throw new Error(\"coordinates is required\");\n    }\n    if (!Array.isArray(coordinates)) {\n        throw new Error(\"coordinates must be an Array\");\n    }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be at least 2 numbers long\");\n    }\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n        throw new Error(\"coordinates must contain numbers\");\n    }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nexport function points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nexport function polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nexport function polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nexport function lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nexport function lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nexport function featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nexport function geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return (degrees * 180) / Math.PI;\n}\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return (radians * Math.PI) / 180;\n}\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nexport function convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\nexport function convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input) {\n    return !!input && input.constructor === Object;\n}\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nexport function validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nexport function validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\n","import { isNumber, } from \"@turf/helpers\";\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nexport function getCoord(coord) {\n    if (!coord) {\n        throw new Error(\"coord is required\");\n    }\n    if (!Array.isArray(coord)) {\n        if (coord.type === \"Feature\" &&\n            coord.geometry !== null &&\n            coord.geometry.type === \"Point\") {\n            return coord.geometry.coordinates;\n        }\n        if (coord.type === \"Point\") {\n            return coord.coordinates;\n        }\n    }\n    if (Array.isArray(coord) &&\n        coord.length >= 2 &&\n        !Array.isArray(coord[0]) &&\n        !Array.isArray(coord[1])) {\n        return coord;\n    }\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nexport function getCoords(coords) {\n    if (Array.isArray(coords)) {\n        return coords;\n    }\n    // Feature\n    if (coords.type === \"Feature\") {\n        if (coords.geometry !== null) {\n            return coords.geometry.coordinates;\n        }\n    }\n    else {\n        // Geometry\n        if (coords.coordinates) {\n            return coords.coordinates;\n        }\n    }\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\n}\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nexport function containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        isNumber(coordinates[0]) &&\n        isNumber(coordinates[1])) {\n        return true;\n    }\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error(\"coordinates must only contain numbers\");\n}\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function geojsonType(value, type, name) {\n    if (!type || !name) {\n        throw new Error(\"type and name required\");\n    }\n    if (!value || value.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            value.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nexport function featureOf(feature, type, name) {\n    if (!feature) {\n        throw new Error(\"No feature passed\");\n    }\n    if (!name) {\n        throw new Error(\".featureOf() requires a name\");\n    }\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            feature.geometry.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function collectionOf(featureCollection, type, name) {\n    if (!featureCollection) {\n        throw new Error(\"No featureCollection passed\");\n    }\n    if (!name) {\n        throw new Error(\".collectionOf() requires a name\");\n    }\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\n    }\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\n        var feature = _a[_i];\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error(\"Invalid input to \" +\n                name +\n                \": must be a \" +\n                type +\n                \", given \" +\n                feature.geometry.type);\n        }\n    }\n}\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nexport function getGeom(geojson) {\n    if (geojson.type === \"Feature\") {\n        return geojson.geometry;\n    }\n    return geojson;\n}\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message (unused)\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nexport function getType(geojson, _name) {\n    if (geojson.type === \"FeatureCollection\") {\n        return \"FeatureCollection\";\n    }\n    if (geojson.type === \"GeometryCollection\") {\n        return \"GeometryCollection\";\n    }\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n        return geojson.geometry.type;\n    }\n    return geojson.type;\n}\n","import { getCoord } from \"@turf/invariant\";\nimport { radiansToLength, degreesToRadians } from \"@turf/helpers\";\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n/**\n * Calculates the distance between two {@link Point|points} in degrees, radians, miles, or kilometers.\n * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name distance\n * @param {Coord} from origin point\n * @param {Coord} to destination point\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {number} distance between the two points\n * @example\n * var from = turf.point([-75.343, 39.984]);\n * var to = turf.point([-75.534, 39.123]);\n * var options = {units: 'miles'};\n *\n * var distance = turf.distance(from, to, options);\n *\n * //addToMap\n * var addToMap = [from, to];\n * from.properties.distance = distance;\n * to.properties.distance = distance;\n */\nfunction distance(from, to, options) {\n    if (options === void 0) { options = {}; }\n    var coordinates1 = getCoord(from);\n    var coordinates2 = getCoord(to);\n    var dLat = degreesToRadians(coordinates2[1] - coordinates1[1]);\n    var dLon = degreesToRadians(coordinates2[0] - coordinates1[0]);\n    var lat1 = degreesToRadians(coordinates1[1]);\n    var lat2 = degreesToRadians(coordinates2[1]);\n    var a = Math.pow(Math.sin(dLat / 2), 2) +\n        Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n    return radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), options.units);\n}\nexport default distance;\n","// http://en.wikipedia.org/wiki/Haversine_formula\n// http://www.movable-type.co.uk/scripts/latlong.html\nimport { degreesToRadians, lengthToRadians, point, radiansToDegrees, } from \"@turf/helpers\";\nimport { getCoord } from \"@turf/invariant\";\n/**\n * Takes a {@link Point} and calculates the location of a destination point given a distance in\n * degrees, radians, miles, or kilometers; and bearing in degrees.\n * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name destination\n * @param {Coord} origin starting point\n * @param {number} distance distance from the origin point\n * @param {number} bearing ranging from -180 to 180\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians\n * @param {Object} [options.properties={}] Translate properties to Point\n * @returns {Feature<Point>} destination point\n * @example\n * var point = turf.point([-75.343, 39.984]);\n * var distance = 50;\n * var bearing = 90;\n * var options = {units: 'miles'};\n *\n * var destination = turf.destination(point, distance, bearing, options);\n *\n * //addToMap\n * var addToMap = [point, destination]\n * destination.properties['marker-color'] = '#f00';\n * point.properties['marker-color'] = '#0f0';\n */\nexport default function destination(origin, distance, bearing, options) {\n    if (options === void 0) { options = {}; }\n    // Handle input\n    var coordinates1 = getCoord(origin);\n    var longitude1 = degreesToRadians(coordinates1[0]);\n    var latitude1 = degreesToRadians(coordinates1[1]);\n    var bearingRad = degreesToRadians(bearing);\n    var radians = lengthToRadians(distance, options.units);\n    // Main\n    var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) +\n        Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad));\n    var longitude2 = longitude1 +\n        Math.atan2(Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1), Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));\n    var lng = radiansToDegrees(longitude2);\n    var lat = radiansToDegrees(latitude2);\n    return point([lng, lat], options.properties);\n}\n","import { getGrid, getGridCell } from './calc';\n\n/** @typedef {import('maplibre-gl').Map} Map */\n/** @typedef {import('maplibre-gl').GeoJSONSource} GeoJSONSource */\n/** @typedef {import('maplibre-gl').LngLatBounds} LngLatBounds */\n/** @typedef {import('maplibre-gl').MapMouseEvent} MapMouseEvent */\n/** @typedef {import('@turf/helpers').Units} Units */\n/** @typedef {import('./grid').GridConfig} GridConfig */\n/** @typedef {import('./grid').GridClickEvent} GridClickEvent */\n\nexport const GRID_CLICK_EVENT = 'grid.click';\n\nexport function randomString() {\n  return Math.floor(Math.random() * 10e12).toString(36);\n}\nexport class Grid {\n  /**\n   * @param {GridConfig} config\n   */\n  constructor(config) {\n    this.id = `grid-${randomString()}`;\n    this.config = config;\n\n    this.updateBound = this.update.bind(this);\n    this.onMapClickBound = this.onMapClick.bind(this);\n  }\n\n  /**\n   * @param {Map} map\n   * @returns {HTMLElement}\n   */\n  onAdd(map) {\n    this.map = map;\n\n    this.map.on('load', this.updateBound);\n    this.map.on('move', this.updateBound);\n    this.map.on('click', this.onMapClickBound);\n\n    if (this.map.loaded()) {\n      this.update();\n    }\n\n    return document.createElement('div');\n  }\n\n  /**\n   * @returns {void}\n   */\n  onRemove() {\n    if (!this.map) {\n      return;\n    }\n\n    const source = this.map.getSource(this.id);\n    if (source) {\n      this.map.removeLayer(this.id);\n      this.map.removeSource(this.id);\n    }\n\n    this.map.off('load', this.updateBound);\n    this.map.off('move', this.updateBound);\n    this.map.off('click', this.onMapClickBound);\n\n    this.map = undefined;\n  }\n\n  /**\n   * @returns {void}\n   */\n  update() {\n    if (!this.map) {\n      return;\n    }\n\n    /** @type {GeoJSON.Feature<GeoJSON.LineString>[]} */\n    let grid = [];\n    if (this.active) {\n      grid = getGrid(this.bbox, this.config.gridWidth, this.config.gridHeight, this.config.units);\n    }\n    // console.log(grid);\n\n    const source = /** @type {GeoJSONSource} */ (this.map.getSource(this.id));\n    if (!source) {\n      this.map.addSource(this.id, {\n        type: 'geojson',\n        data: { type: 'FeatureCollection', features: grid }\n      });\n      this.map.addLayer({\n        id: this.id,\n        source: this.id,\n        type: 'line',\n        paint: this.config.paint ?? {}\n      });\n    } else {\n      source.setData({ type: 'FeatureCollection', features: grid });\n    }\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  get active() {\n    if (!this.map) {\n      return false;\n    }\n\n    const minZoom = this.config.minZoom ?? 0;\n    const maxZoom = this.config.maxZoom ?? 22;\n    const zoom = this.map.getZoom();\n    // console.log(zoom);\n\n    return minZoom <= zoom && zoom < maxZoom;\n  }\n\n  /**\n   * @returns {GeoJSON.BBox}\n   */\n  get bbox() {\n    if (!this.map) {\n      throw new Error('Invalid state');\n    }\n\n    const bounds = this.map.getBounds();\n    if (bounds.getEast() - bounds.getWest() >= 360) {\n      bounds.setNorthEast([bounds.getWest() + 360, bounds.getNorth()]);\n    }\n\n    const bbox = /** @type {GeoJSON.BBox} */ (bounds.toArray().flat());\n    return bbox;\n  }\n\n  /**\n   * @param {MapMouseEvent} event\n   * @returns {void}\n   */\n  onMapClick(event) {\n    if (!this.map || !this.active) {\n      return;\n    }\n\n    const point = event.lngLat.toArray();\n    const bbox = getGridCell(point, this.config.gridWidth, this.config.gridWidth, this.config.units);\n\n    /** @type {GridClickEvent} */\n    const event2 = { bbox };\n    this.map.fire(GRID_CLICK_EVENT, event2);\n  }\n}","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","import distance from '@turf/distance';\nimport destination from '@turf/destination';\n\n/** @typedef {import('@turf/helpers').Units} Units */\n\n/**\n * @param {GeoJSON.BBox} bbox\n * @param {number} gridWidth\n * @param {number} gridHeight\n * @param {Units} units\n * @returns {GeoJSON.Feature<GeoJSON.LineString>[]}\n */\nexport function getGrid(bbox, gridWidth, gridHeight, units) {\n  // return rectangleGrid(bbox, gridWidth, gridHeight, { units });\n\n  const earthCircumference = Math.ceil(distance([0, 0], [180, 0], { units }) * 2);\n  const maxColumns = Math.floor(earthCircumference / gridWidth);\n  /** @type {(from: GeoJSON.Position, to: GeoJSON.Position, options: { units: Units }) => number} */\n  const fullDistance = (from, to, options) => {\n    const dist = distance(from, to, options);\n    if (Math.abs(to[0] - from[0]) >= 180) {\n      return earthCircumference - dist;\n    }\n    return dist;\n  };\n\n  /** @type {GeoJSON.Feature<GeoJSON.LineString>[]} */\n  const features = [];\n  const west = bbox[0];\n  const south = bbox[1];\n  const east = bbox[2];\n  const north = bbox[3];\n\n  // calculate grid start point\n  const deltaX = (west < 0 ? -1 : 1) * fullDistance([0, 0], [west, 0], { units });\n  const deltaY = (south < 0 ? -1 : 1) * fullDistance([0, 0], [0, south], { units });\n  const startDeltaX = Math.ceil(deltaX / gridWidth) * gridWidth;\n  const startDeltaY = Math.ceil(deltaY / gridHeight) * gridHeight;\n  /** @type {GeoJSON.Position} */\n  const startPoint = [\n    destination([0, 0], startDeltaX, 90, { units }).geometry.coordinates[0],\n    destination([0, 0], startDeltaY, 0, { units }).geometry.coordinates[1]\n  ];\n\n  // calculate grid columns and rows count\n  const width = fullDistance([west, 0], [east, 0], { units });\n  const height = fullDistance([0, south], [0, north], { units });\n  const columns = Math.min(Math.ceil(width / gridWidth), maxColumns);\n  const rows = Math.ceil(height / gridHeight);\n  // console.log(startPoint, columns, rows);\n\n  /** @type {GeoJSON.Position} */\n  let currentPoint;\n\n  // meridians\n  currentPoint = startPoint;\n  for (let i = 0; i < columns; i++) {\n    /** @type {GeoJSON.Position[]} */\n    const coordinates = [\n      [currentPoint[0], south],\n      [currentPoint[0], north]\n    ];\n    /** @type {GeoJSON.Feature<GeoJSON.LineString>} */\n    const feature = { type: 'Feature', geometry: { type: 'LineString', coordinates }, properties: {}};\n    features.push(feature);\n\n    currentPoint = [\n      destination([currentPoint[0], 0], gridWidth, 90, { units }).geometry.coordinates[0],\n      currentPoint[1]\n    ];\n  }\n\n  // parallels\n  currentPoint = startPoint;\n  for (let i = 0; i < rows; i++) {\n    /** @type {GeoJSON.Position[]} */\n    const coordinates = [\n      [west, currentPoint[1]],\n      [east, currentPoint[1]]\n    ];\n    /** @type {GeoJSON.Feature<GeoJSON.LineString>} */\n    const feature = { type: 'Feature', geometry: { type: 'LineString', coordinates }, properties: {}};\n    features.push(feature);\n\n    currentPoint = [\n      currentPoint[0],\n      destination([0, currentPoint[1]], gridHeight, 0, { units }).geometry.coordinates[1]\n    ];\n  }\n\n  return features;\n}\n\n/**\n * @param {GeoJSON.Position} point\n * @param {number} gridWidth\n * @param {number} gridHeight\n * @param {Units} units\n * @returns {GeoJSON.BBox}\n */\nexport function getGridCell(point, gridWidth, gridHeight, units) {\n  const earthCircumference = Math.ceil(distance([0, 0], [180, 0], { units }) * 2);\n  /** @type {(from: GeoJSON.Position, to: GeoJSON.Position, options: { units: Units }) => number} */\n  const fullDistance = (from, to, options) => {\n    const dist = distance(from, to, options);\n    if (Math.abs(to[0] - from[0]) >= 180) {\n      return earthCircumference - dist;\n    }\n    return dist;\n  };\n\n  const deltaX = (point[0] < 0 ? -1 : 1) * fullDistance([0, 0], [point[0], 0], { units });\n  const deltaY = (point[1] < 0 ? -1 : 1) * fullDistance([0, 0], [0, point[1]], { units });\n  const minDeltaX = Math.floor(deltaX / gridWidth) * gridWidth;\n  const minDeltaY = Math.floor(deltaY / gridHeight) * gridHeight;\n  const maxDeltaX = Math.ceil(deltaX / gridWidth) * gridWidth;\n  const maxDeltaY = Math.ceil(deltaY / gridHeight) * gridHeight;\n  const bbox = /** @type {GeoJSON.BBox} */ ([\n    destination([0, 0], minDeltaX, 90, { units }).geometry.coordinates[0],\n    destination([0, 0], minDeltaY, 0, { units }).geometry.coordinates[1],\n    destination([0, 0], maxDeltaX, 90, { units }).geometry.coordinates[0],\n    destination([0, 0], maxDeltaY, 0, { units }).geometry.coordinates[1]\n  ]);\n\n  return bbox;\n}"],"names":["_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","earthRadius","factors","centimeters","centimetres","degrees","feet","inches","kilometers","kilometres","meters","metres","miles","millimeters","millimetres","nauticalmiles","radians","yards","radiansToDegrees","Math","PI","degreesToRadians","isNumber","num","isNaN","Array","isArray","getCoord","coord","Error","type","geometry","coordinates","distance","from","to","options","coordinates1","coordinates2","dLat","dLon","lat1","lat2","a","pow","sin","cos","units","factor","radiansToLength","atan2","sqrt","destination","origin","bearing","longitude1","latitude1","bearingRad","lengthToRadians","latitude2","asin","properties","geom","feat","id","bbox","feature","point","GRID_CLICK_EVENT","randomString","floor","random","toString","Grid","config","instance","Constructor","TypeError","updateBound","this","update","bind","onMapClickBound","onMapClick","protoProps","staticProps","map","on","loaded","document","createElement","getSource","removeLayer","removeSource","off","undefined","grid","active","gridWidth","gridHeight","currentPoint","earthCircumference","ceil","maxColumns","fullDistance","dist","abs","features","west","south","east","north","deltaX","deltaY","startDeltaX","startDeltaY","startPoint","width","height","columns","min","rows","push","getGrid","source","setData","addSource","data","addLayer","paint","minZoom","maxZoom","zoom","getZoom","bounds","getBounds","getEast","getWest","setNorthEast","getNorth","toArray","flat","event","event2","minDeltaX","minDeltaY","maxDeltaX","maxDeltaY","getGridCell","lngLat","fire","prototype"],"mappings":"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"}