{"version":3,"file":"maplibre-grid.js","sources":["../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/@babel/runtime/helpers/esm/createClass.js","../node_modules/@turf/helpers/dist/es/index.js","../node_modules/@turf/invariant/dist/es/index.js","../node_modules/@turf/distance/dist/es/index.js","../node_modules/@turf/destination/dist/es/index.js","../src/calc.js","../src/grid.js"],"sourcesContent":["export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}","/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexport var earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var factors = {\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    degrees: earthRadius / 111325,\n    feet: earthRadius * 3.28084,\n    inches: earthRadius * 39.37,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    meters: earthRadius,\n    metres: earthRadius,\n    miles: earthRadius / 1609.344,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    nauticalmiles: earthRadius / 1852,\n    radians: 1,\n    yards: earthRadius / 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.37,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / earthRadius,\n    yards: 1 / 1.0936,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    hectares: 0.0001,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nexport function geometry(type, coordinates, _options) {\n    if (_options === void 0) { _options = {}; }\n    switch (type) {\n        case \"Point\":\n            return point(coordinates).geometry;\n        case \"LineString\":\n            return lineString(coordinates).geometry;\n        case \"Polygon\":\n            return polygon(coordinates).geometry;\n        case \"MultiPoint\":\n            return multiPoint(coordinates).geometry;\n        case \"MultiLineString\":\n            return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\":\n            return multiPolygon(coordinates).geometry;\n        default:\n            throw new Error(type + \" is invalid\");\n    }\n}\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (!coordinates) {\n        throw new Error(\"coordinates is required\");\n    }\n    if (!Array.isArray(coordinates)) {\n        throw new Error(\"coordinates must be an Array\");\n    }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be at least 2 numbers long\");\n    }\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n        throw new Error(\"coordinates must contain numbers\");\n    }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nexport function points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nexport function polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nexport function polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nexport function lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nexport function lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nexport function featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nexport function geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return (degrees * 180) / Math.PI;\n}\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return (radians * Math.PI) / 180;\n}\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nexport function convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\nexport function convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input) {\n    return !!input && input.constructor === Object;\n}\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nexport function validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nexport function validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\n","import { isNumber, } from \"@turf/helpers\";\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nexport function getCoord(coord) {\n    if (!coord) {\n        throw new Error(\"coord is required\");\n    }\n    if (!Array.isArray(coord)) {\n        if (coord.type === \"Feature\" &&\n            coord.geometry !== null &&\n            coord.geometry.type === \"Point\") {\n            return coord.geometry.coordinates;\n        }\n        if (coord.type === \"Point\") {\n            return coord.coordinates;\n        }\n    }\n    if (Array.isArray(coord) &&\n        coord.length >= 2 &&\n        !Array.isArray(coord[0]) &&\n        !Array.isArray(coord[1])) {\n        return coord;\n    }\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nexport function getCoords(coords) {\n    if (Array.isArray(coords)) {\n        return coords;\n    }\n    // Feature\n    if (coords.type === \"Feature\") {\n        if (coords.geometry !== null) {\n            return coords.geometry.coordinates;\n        }\n    }\n    else {\n        // Geometry\n        if (coords.coordinates) {\n            return coords.coordinates;\n        }\n    }\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\n}\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nexport function containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        isNumber(coordinates[0]) &&\n        isNumber(coordinates[1])) {\n        return true;\n    }\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error(\"coordinates must only contain numbers\");\n}\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function geojsonType(value, type, name) {\n    if (!type || !name) {\n        throw new Error(\"type and name required\");\n    }\n    if (!value || value.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            value.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nexport function featureOf(feature, type, name) {\n    if (!feature) {\n        throw new Error(\"No feature passed\");\n    }\n    if (!name) {\n        throw new Error(\".featureOf() requires a name\");\n    }\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            feature.geometry.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function collectionOf(featureCollection, type, name) {\n    if (!featureCollection) {\n        throw new Error(\"No featureCollection passed\");\n    }\n    if (!name) {\n        throw new Error(\".collectionOf() requires a name\");\n    }\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\n    }\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\n        var feature = _a[_i];\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error(\"Invalid input to \" +\n                name +\n                \": must be a \" +\n                type +\n                \", given \" +\n                feature.geometry.type);\n        }\n    }\n}\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nexport function getGeom(geojson) {\n    if (geojson.type === \"Feature\") {\n        return geojson.geometry;\n    }\n    return geojson;\n}\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message (unused)\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nexport function getType(geojson, _name) {\n    if (geojson.type === \"FeatureCollection\") {\n        return \"FeatureCollection\";\n    }\n    if (geojson.type === \"GeometryCollection\") {\n        return \"GeometryCollection\";\n    }\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n        return geojson.geometry.type;\n    }\n    return geojson.type;\n}\n","import { getCoord } from \"@turf/invariant\";\nimport { radiansToLength, degreesToRadians } from \"@turf/helpers\";\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n/**\n * Calculates the distance between two {@link Point|points} in degrees, radians, miles, or kilometers.\n * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name distance\n * @param {Coord} from origin point\n * @param {Coord} to destination point\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {number} distance between the two points\n * @example\n * var from = turf.point([-75.343, 39.984]);\n * var to = turf.point([-75.534, 39.123]);\n * var options = {units: 'miles'};\n *\n * var distance = turf.distance(from, to, options);\n *\n * //addToMap\n * var addToMap = [from, to];\n * from.properties.distance = distance;\n * to.properties.distance = distance;\n */\nfunction distance(from, to, options) {\n    if (options === void 0) { options = {}; }\n    var coordinates1 = getCoord(from);\n    var coordinates2 = getCoord(to);\n    var dLat = degreesToRadians(coordinates2[1] - coordinates1[1]);\n    var dLon = degreesToRadians(coordinates2[0] - coordinates1[0]);\n    var lat1 = degreesToRadians(coordinates1[1]);\n    var lat2 = degreesToRadians(coordinates2[1]);\n    var a = Math.pow(Math.sin(dLat / 2), 2) +\n        Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n    return radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), options.units);\n}\nexport default distance;\n","// http://en.wikipedia.org/wiki/Haversine_formula\n// http://www.movable-type.co.uk/scripts/latlong.html\nimport { degreesToRadians, lengthToRadians, point, radiansToDegrees, } from \"@turf/helpers\";\nimport { getCoord } from \"@turf/invariant\";\n/**\n * Takes a {@link Point} and calculates the location of a destination point given a distance in\n * degrees, radians, miles, or kilometers; and bearing in degrees.\n * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name destination\n * @param {Coord} origin starting point\n * @param {number} distance distance from the origin point\n * @param {number} bearing ranging from -180 to 180\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians\n * @param {Object} [options.properties={}] Translate properties to Point\n * @returns {Feature<Point>} destination point\n * @example\n * var point = turf.point([-75.343, 39.984]);\n * var distance = 50;\n * var bearing = 90;\n * var options = {units: 'miles'};\n *\n * var destination = turf.destination(point, distance, bearing, options);\n *\n * //addToMap\n * var addToMap = [point, destination]\n * destination.properties['marker-color'] = '#f00';\n * point.properties['marker-color'] = '#0f0';\n */\nexport default function destination(origin, distance, bearing, options) {\n    if (options === void 0) { options = {}; }\n    // Handle input\n    var coordinates1 = getCoord(origin);\n    var longitude1 = degreesToRadians(coordinates1[0]);\n    var latitude1 = degreesToRadians(coordinates1[1]);\n    var bearingRad = degreesToRadians(bearing);\n    var radians = lengthToRadians(distance, options.units);\n    // Main\n    var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) +\n        Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad));\n    var longitude2 = longitude1 +\n        Math.atan2(Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1), Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));\n    var lng = radiansToDegrees(longitude2);\n    var lat = radiansToDegrees(latitude2);\n    return point([lng, lat], options.properties);\n}\n","import distance from '@turf/distance';\nimport destination from '@turf/destination';\n\n/** @typedef {import('@turf/helpers').Units} Units */\n\n/**\n * @param {GeoJSON.BBox} bbox\n * @param {number} gridWidth\n * @param {number} gridHeight\n * @param {Units} units\n * @returns {GeoJSON.Feature<GeoJSON.LineString>[]}\n */\nexport function getGrid(bbox, gridWidth, gridHeight, units) {\n  // return rectangleGrid(bbox, gridWidth, gridHeight, { units });\n\n  const earthCircumference = Math.ceil(distance([0, 0], [180, 0], { units }) * 2);\n  const maxColumns = Math.floor(earthCircumference / gridWidth);\n  /** @type {(from: GeoJSON.Position, to: GeoJSON.Position, options: { units: Units }) => number} */\n  const fullDistance = (from, to, options) => {\n    const dist = distance(from, to, options);\n    if (Math.abs(to[0] - from[0]) >= 180) {\n      return earthCircumference - dist;\n    }\n    return dist;\n  };\n\n  /** @type {GeoJSON.Feature<GeoJSON.LineString>[]} */\n  const features = [];\n  const west = bbox[0];\n  const south = bbox[1];\n  const east = bbox[2];\n  const north = bbox[3];\n\n  // calculate grid start point\n  const deltaX = (west < 0 ? -1 : 1) * fullDistance([0, 0], [west, 0], { units });\n  const deltaY = (south < 0 ? -1 : 1) * fullDistance([0, 0], [0, south], { units });\n  const startDeltaX = Math.ceil(deltaX / gridWidth) * gridWidth;\n  const startDeltaY = Math.ceil(deltaY / gridHeight) * gridHeight;\n  /** @type {GeoJSON.Position} */\n  const startPoint = [\n    destination([0, 0], startDeltaX, 90, { units }).geometry.coordinates[0],\n    destination([0, 0], startDeltaY, 0, { units }).geometry.coordinates[1]\n  ];\n\n  // calculate grid columns and rows count\n  const width = fullDistance([west, 0], [east, 0], { units });\n  const height = fullDistance([0, south], [0, north], { units });\n  const columns = Math.min(Math.ceil(width / gridWidth), maxColumns);\n  const rows = Math.ceil(height / gridHeight);\n  // console.log(startPoint, columns, rows);\n\n  /** @type {GeoJSON.Position} */\n  let currentPoint;\n\n  // meridians\n  currentPoint = startPoint;\n  for (let i = 0; i < columns; i++) {\n    /** @type {GeoJSON.Position[]} */\n    const coordinates = [\n      [currentPoint[0], south],\n      [currentPoint[0], north]\n    ];\n    /** @type {GeoJSON.Feature<GeoJSON.LineString>} */\n    const feature = { type: 'Feature', geometry: { type: 'LineString', coordinates }, properties: {}};\n    features.push(feature);\n\n    currentPoint = [\n      destination([currentPoint[0], 0], gridWidth, 90, { units }).geometry.coordinates[0],\n      currentPoint[1]\n    ];\n  }\n\n  // parallels\n  currentPoint = startPoint;\n  for (let i = 0; i < rows; i++) {\n    /** @type {GeoJSON.Position[]} */\n    const coordinates = [\n      [west, currentPoint[1]],\n      [east, currentPoint[1]]\n    ];\n    /** @type {GeoJSON.Feature<GeoJSON.LineString>} */\n    const feature = { type: 'Feature', geometry: { type: 'LineString', coordinates }, properties: {}};\n    features.push(feature);\n\n    currentPoint = [\n      currentPoint[0],\n      destination([0, currentPoint[1]], gridHeight, 0, { units }).geometry.coordinates[1]\n    ];\n  }\n\n  return features;\n}\n\n/**\n * @param {GeoJSON.Position} point\n * @param {number} gridWidth\n * @param {number} gridHeight\n * @param {Units} units\n * @returns {GeoJSON.BBox}\n */\nexport function getGridCell(point, gridWidth, gridHeight, units) {\n  const earthCircumference = Math.ceil(distance([0, 0], [180, 0], { units }) * 2);\n  /** @type {(from: GeoJSON.Position, to: GeoJSON.Position, options: { units: Units }) => number} */\n  const fullDistance = (from, to, options) => {\n    const dist = distance(from, to, options);\n    if (Math.abs(to[0] - from[0]) >= 180) {\n      return earthCircumference - dist;\n    }\n    return dist;\n  };\n\n  const deltaX = (point[0] < 0 ? -1 : 1) * fullDistance([0, 0], [point[0], 0], { units });\n  const deltaY = (point[1] < 0 ? -1 : 1) * fullDistance([0, 0], [0, point[1]], { units });\n  const minDeltaX = Math.floor(deltaX / gridWidth) * gridWidth;\n  const minDeltaY = Math.floor(deltaY / gridHeight) * gridHeight;\n  const maxDeltaX = Math.ceil(deltaX / gridWidth) * gridWidth;\n  const maxDeltaY = Math.ceil(deltaY / gridHeight) * gridHeight;\n  const bbox = /** @type {GeoJSON.BBox} */ ([\n    destination([0, 0], minDeltaX, 90, { units }).geometry.coordinates[0],\n    destination([0, 0], minDeltaY, 0, { units }).geometry.coordinates[1],\n    destination([0, 0], maxDeltaX, 90, { units }).geometry.coordinates[0],\n    destination([0, 0], maxDeltaY, 0, { units }).geometry.coordinates[1]\n  ]);\n\n  return bbox;\n}","import { getGrid, getGridCell } from './calc';\n\n/** @typedef {import('maplibre-gl').Map} Map */\n/** @typedef {import('maplibre-gl').GeoJSONSource} GeoJSONSource */\n/** @typedef {import('maplibre-gl').LngLatBounds} LngLatBounds */\n/** @typedef {import('maplibre-gl').MapMouseEvent} MapMouseEvent */\n/** @typedef {import('@turf/helpers').Units} Units */\n/** @typedef {import('./grid').GridConfig} GridConfig */\n/** @typedef {import('./grid').GridClickEvent} GridClickEvent */\n\nexport const GRID_CLICK_EVENT = 'grid.click';\n\nexport function randomString() {\n  return Math.floor(Math.random() * 10e12).toString(36);\n}\nexport class Grid {\n  /**\n   * @param {GridConfig} config\n   */\n  constructor(config) {\n    this.id = `grid-${randomString()}`;\n    this.config = config;\n\n    this.updateBound = this.update.bind(this);\n    this.onMapClickBound = this.onMapClick.bind(this);\n  }\n\n  /**\n   * @param {Map} map\n   * @returns {HTMLElement}\n   */\n  onAdd(map) {\n    this.map = map;\n\n    this.map.on('load', this.updateBound);\n    this.map.on('move', this.updateBound);\n    this.map.on('click', this.onMapClickBound);\n\n    if (this.map.loaded()) {\n      this.update();\n    }\n\n    return document.createElement('div');\n  }\n\n  /**\n   * @returns {void}\n   */\n  onRemove() {\n    if (!this.map) {\n      return;\n    }\n\n    const source = this.map.getSource(this.id);\n    if (source) {\n      this.map.removeLayer(this.id);\n      this.map.removeSource(this.id);\n    }\n\n    this.map.off('load', this.updateBound);\n    this.map.off('move', this.updateBound);\n    this.map.off('click', this.onMapClickBound);\n\n    this.map = undefined;\n  }\n\n  /**\n   * @returns {void}\n   */\n  update() {\n    if (!this.map) {\n      return;\n    }\n\n    /** @type {GeoJSON.Feature<GeoJSON.LineString>[]} */\n    let grid = [];\n    if (this.active) {\n      grid = getGrid(this.bbox, this.config.gridWidth, this.config.gridHeight, this.config.units);\n    }\n    // console.log(grid);\n\n    const source = /** @type {GeoJSONSource} */ (this.map.getSource(this.id));\n    if (!source) {\n      this.map.addSource(this.id, {\n        type: 'geojson',\n        data: { type: 'FeatureCollection', features: grid }\n      });\n      this.map.addLayer({\n        id: this.id,\n        source: this.id,\n        type: 'line',\n        paint: this.config.paint ?? {}\n      });\n    } else {\n      source.setData({ type: 'FeatureCollection', features: grid });\n    }\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  get active() {\n    if (!this.map) {\n      return false;\n    }\n\n    const minZoom = this.config.minZoom ?? 0;\n    const maxZoom = this.config.maxZoom ?? 22;\n    const zoom = this.map.getZoom();\n    // console.log(zoom);\n\n    return minZoom <= zoom && zoom < maxZoom;\n  }\n\n  /**\n   * @returns {GeoJSON.BBox}\n   */\n  get bbox() {\n    if (!this.map) {\n      throw new Error('Invalid state');\n    }\n\n    const bounds = this.map.getBounds();\n    if (bounds.getEast() - bounds.getWest() >= 360) {\n      bounds.setNorthEast([bounds.getWest() + 360, bounds.getNorth()]);\n    }\n\n    const bbox = /** @type {GeoJSON.BBox} */ (bounds.toArray().flat());\n    return bbox;\n  }\n\n  /**\n   * @param {MapMouseEvent} event\n   * @returns {void}\n   */\n  onMapClick(event) {\n    if (!this.map || !this.active) {\n      return;\n    }\n\n    const point = event.lngLat.toArray();\n    const bbox = getGridCell(point, this.config.gridWidth, this.config.gridWidth, this.config.units);\n\n    /** @type {GridClickEvent} */\n    const event2 = { bbox };\n    this.map.fire(GRID_CLICK_EVENT, event2);\n  }\n}"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","earthRadius","factors","centimeters","centimetres","degrees","feet","inches","kilometers","kilometres","meters","metres","miles","millimeters","millimetres","nauticalmiles","radians","yards","feature","geom","properties","options","feat","type","id","bbox","geometry","point","coordinates","Error","Array","isArray","isNumber","radiansToLength","units","factor","lengthToRadians","distance","radiansToDegrees","Math","PI","degreesToRadians","num","isNaN","getCoord","coord","from","to","coordinates1","coordinates2","dLat","dLon","lat1","lat2","a","pow","sin","cos","atan2","sqrt","destination","origin","bearing","longitude1","latitude1","bearingRad","latitude2","asin","longitude2","lng","lat","getGrid","gridWidth","gridHeight","earthCircumference","ceil","maxColumns","floor","fullDistance","dist","abs","features","west","south","east","north","deltaX","deltaY","startDeltaX","startDeltaY","startPoint","width","height","columns","min","rows","currentPoint","push","getGridCell","minDeltaX","minDeltaY","maxDeltaX","maxDeltaY","GRID_CLICK_EVENT","randomString","random","toString","Grid","config","updateBound","update","bind","onMapClickBound","onMapClick","map","on","loaded","document","createElement","source","getSource","removeLayer","removeSource","off","undefined","grid","active","addSource","data","addLayer","paint","setData","minZoom","maxZoom","zoom","getZoom","bounds","getBounds","getEast","getWest","setNorthEast","getNorth","toArray","flat","event","lngLat","event2","fire"],"mappings":"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"}